<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Bionics - Procedural Lobster</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
<script>

// --- CONFIGURATION ---
const PARTICLE_COUNT = 800;
const PARTICLE_COLOR = [0, 255, 255]; // Cyan
const MAX_SPEED = 2;
const MOUSE_REPEL_RADIUS = 150;
const MOUSE_REPEL_STRENGTH = 0.8;

let particles = [];
let attractors = [];

// --- PARTICLE CLASS ---
// Represents a single point of light
class Particle {
    constructor() {
        this.pos = createVector(random(width), random(height));
        this.vel = p5.Vector.random2D();
        this.acc = createVector();
        this.maxSpeed = MAX_SPEED;
        this.noiseOffset = createVector(random(1000), random(1000));
    }

    // Apply a force to the particle
    applyForce(force) {
        this.acc.add(force);
    }

    // Update particle's position
    update() {
        this.vel.add(this.acc);
        this.vel.limit(this.maxSpeed);
        this.pos.add(this.vel);
        this.acc.mult(0); // Reset acceleration each frame
    }

    // Display the particle
    show() {
        strokeWeight(2);
        stroke(PARTICLE_COLOR[0], PARTICLE_COLOR[1], PARTICLE_COLOR[2], 150);
        point(this.pos.x, this.pos.y);
    }

    // Define behaviors like seeking and fleeing
    behaviors() {
        // 1. Attraction to the lobster shape
        let seekForce = this.seek(this.findClosestAttractor());
        seekForce.mult(0.2);
        this.applyForce(seekForce);

        // 2. Repulsion from the mouse
        let mouse = createVector(mouseX, mouseY);
        let distanceToMouse = dist(this.pos.x, this.pos.y, mouse.x, mouse.y);
        if (distanceToMouse < MOUSE_REPEL_RADIUS) {
            let repelForce = p5.Vector.sub(this.pos, mouse);
            let repelStrength = map(distanceToMouse, 0, MOUSE_REPEL_RADIUS, MOUSE_REPEL_STRENGTH, 0);
            repelForce.setMag(repelStrength);
            this.applyForce(repelForce);
        }

        // 3. Organic wandering movement using Perlin noise
        let noiseForce = createVector(
            map(noise(this.noiseOffset.x), 0, 1, -0.1, 0.1),
            map(noise(this.noiseOffset.y), 0, 1, -0.1, 0.1)
        );
        this.applyForce(noiseForce);
        this.noiseOffset.add(0.01, 0.01);
    }

    // Find the closest point on the lobster skeleton
    findClosestAttractor() {
        let closestDist = Infinity;
        let closestAttractor = null;
        for (let attractor of attractors) {
            let d = dist(this.pos.x, this.pos.y, attractor.x, attractor.y);
            if (d < closestDist) {
                closestDist = d;
                closestAttractor = attractor;
            }
        }
        return closestAttractor;
    }

    // Steering behavior to seek a target
    seek(target) {
        if (!target) return createVector(0, 0);
        let desired = p5.Vector.sub(target, this.pos);
        desired.setMag(this.maxSpeed);
        let steer = p5.Vector.sub(desired, this.vel);
        steer.limit(0.5); // Steering ability
        return steer;
    }
}

// --- P5.JS MAIN FUNCTIONS ---

function setup() {
    createCanvas(windowWidth, windowHeight);
    
    // Define the "skeleton" of the lobster with two raised claws
    // The points are vectors defining the shape in the center of the screen
    let centerX = width / 2;
    let centerY = height / 2;
    let bodyHeight = 150;
    let clawReach = 120;
    let clawHeight = 100;

    // Body and Tail
    for (let i = 0; i < bodyHeight; i += 5) {
        attractors.push(createVector(centerX, centerY - (bodyHeight/2) + i));
    }
    // Tail fan
    attractors.push(createVector(centerX - 15, centerY + (bodyHeight/2) + 10));
    attractors.push(createVector(centerX + 15, centerY + (bodyHeight/2) + 10));

    // Right Claw
    for(let i=0; i<clawReach; i += 5) {
        let angle = -PI / 4;
        let x = centerX + 20 + cos(angle) * i;
        let y = centerY - 50 + sin(angle) * i;
        attractors.push(createVector(x,y));
    }
     for(let i=0; i<40; i += 5) { // pincer 1
        let x = centerX + 20 + cos(-PI/4) * clawReach + cos(-PI/8) * i;
        let y = centerY - 50 + sin(-PI/4) * clawReach + sin(-PI/8) * i;
        attractors.push(createVector(x,y));
    }
     for(let i=0; i<40; i += 5) { // pincer 2
        let x = centerX + 20 + cos(-PI/4) * clawReach + cos(-PI/2.5) * i;
        let y = centerY - 50 + sin(-PI/4) * clawReach + sin(-PI/2.5) * i;
        attractors.push(createVector(x,y));
    }

    // Left Claw
    for(let i=0; i<clawReach; i += 5) {
        let angle = -3 * PI / 4;
        let x = centerX - 20 + cos(angle) * i;
        let y = centerY - 50 + sin(angle) * i;
        attractors.push(createVector(x,y));
    }
    for(let i=0; i<40; i += 5) { // pincer 1
        let x = centerX - 20 + cos(-3*PI/4) * clawReach + cos(-3.5*PI/4) * i;
        let y = centerY - 50 + sin(-3*PI/4) * clawReach + sin(-3.5*PI/4) * i;
        attractors.push(createVector(x,y));
    }
     for(let i=0; i<40; i += 5) { // pincer 2
        let x = centerX - 20 + cos(-3*PI/4) * clawReach + cos(-2.5*PI/4) * i;
        let y = centerY - 50 + sin(-3*PI/4) * clawReach + sin(-2.5*PI/4) * i;
        attractors.push(createVector(x,y));
    }

    // Antennae
    attractors.push(createVector(centerX-15, centerY - 80));
    attractors.push(createVector(centerX+15, centerY - 80));


    // Initialize all particles
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        particles.push(new Particle());
    }
}

function draw() {
    // Semi-transparent background for motion trails
    background(0, 10, 25, 50);

    // Update and display all particles
    for (let p of particles) {
        p.behaviors();
        p.update();
        p.show();
    }
}

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
    // Recalculate attractors on resize to keep it centered
    attractors = [];
    setup(); 
}

</script>
</body>
</html>
